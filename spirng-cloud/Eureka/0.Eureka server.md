

# 0.Eureka server

# 1.核心类

## 1.1.EurekaServerAutoConfiguration

### 1.1.1.注入InstanceResource

该类主要负责Instance注册工作

```java
@Bean
    public PeerAwareInstanceRegistry peerAwareInstanceRegistry(ServerCodecs serverCodecs) {
        this.eurekaClient.getApplications();
        return new InstanceRegistry(this.eurekaServerConfig, this.eurekaClientConfig, serverCodecs, this.eurekaClient, this.instanceRegistryProperties.getExpectedNumberOfClientsSendingRenews(), this.instanceRegistryProperties.getDefaultOpenForTrafficCount());
    }
```

负责处理来自Client请求

```java
@Produces({"application/xml", "application/json"})
public class InstanceResource {
    private static final Logger logger = LoggerFactory.getLogger(InstanceResource.class);
    private final PeerAwareInstanceRegistry registry;
    private final EurekaServerConfig serverConfig;
    private final String id;
    private final ApplicationResource app;

    InstanceResource(ApplicationResource app, String id, EurekaServerConfig serverConfig, PeerAwareInstanceRegistry registry) {
        this.app = app;
        this.id = id;
        this.serverConfig = serverConfig;
        this.registry = registry;
    }

    @GET
    public Response getInstanceInfo() {
        InstanceInfo appInfo = this.registry.getInstanceByAppAndId(this.app.getName(), this.id);
        if (appInfo != null) {
            logger.debug("Found: {} - {}", this.app.getName(), this.id);
            return Response.ok(appInfo).build();
        } else {
            logger.debug("Not Found: {} - {}", this.app.getName(), this.id);
            return Response.status(Status.NOT_FOUND).build();
        }
    }
    // .......
    }
```

##### 处理客户端修改状态请求

```java
   // 入参：isReplication true 表示是server之间的复制同步  false 表示是Client发起到Servrer的复制同步
    @PUT
    @Path("status")
    public Response statusUpdate(@QueryParam("value") String newStatus, @HeaderParam("x-netflix-discovery-replication") String isReplication, @QueryParam("lastDirtyTimestamp") String lastDirtyTimestamp) {
        try {
            // 获取实例
            if (this.registry.getInstanceByAppAndId(this.app.getName(), this.id) == null) {
                logger.warn("Instance not found: {}/{}", this.app.getName(), this.id);
                return Response.status(Status.NOT_FOUND).build();
            } else {
                // 修改实例状态
                boolean isSuccess = this.registry.statusUpdate(this.app.getName(), this.id, InstanceStatus.valueOf(newStatus), lastDirtyTimestamp, "true".equals(isReplication));
                if (isSuccess) {
                    logger.info("Status updated: {} - {} - {}", new Object[]{this.app.getName(), this.id, newStatus});
                    return Response.ok().build();
                } else {
                    logger.warn("Unable to update status: {} - {} - {}", new Object[]{this.app.getName(), this.id, newStatus});
                    return Response.serverError().build();
                }
            }
        } catch (Throwable var5) {
            logger.error("Error updating instance {} for status {}", this.id, newStatus);
            return Response.serverError().build();
        }
    }

// PeerAwareInstanceRegistryImpl.java
// 获取Server端的主机实例
public InstanceInfo getInstanceByAppAndId(String appName, String id) {
        return this.getInstanceByAppAndId(appName, id, true);
    }

    public InstanceInfo getInstanceByAppAndId(String appName, String id, boolean includeRemoteRegions) {
        //  registry就是我们服务端本地的注册表，双层map，外层map，key是微服务名称，value是内层map，
        // 内层map，key是InstanceInfo的Id，value是Lease续约对象，包装了InstanceInfo。
        Map<String, Lease<InstanceInfo>> leaseMap = (Map)this.registry.get(appName);
        Lease<InstanceInfo> lease = null;
        if (leaseMap != null) {
            lease = (Lease)leaseMap.get(id);
        }
         // 如果Lease为空 或者 Server关闭了自我保护并且实例也过期，尝试从远程Region获取注册表
        if (lease == null || this.isLeaseExpirationEnabled() && lease.isExpired()) {
            if (includeRemoteRegions) {
                Iterator var6 = this.regionNameVSRemoteRegistry.values().iterator();

                while(var6.hasNext()) {
                    RemoteRegionRegistry remoteRegistry = (RemoteRegionRegistry)var6.next();
                    Application application = remoteRegistry.getApplication(appName);
                    if (application != null) {
                        return application.getByInstanceId(id);
                    }
                }
            }

            return null;
        } else {
            // 从Lease抽取数据封装Instance
            return this.decorateInstanceInfo(lease);
        }
    }

// AbstractInstanceRegistry.java
private InstanceInfo decorateInstanceInfo(Lease<InstanceInfo> lease) {
        InstanceInfo info = (InstanceInfo)lease.getHolder();
        int renewalInterval = 30;
        int leaseDuration = 90;
        if (info.getLeaseInfo() != null) {
            renewalInterval = info.getLeaseInfo().getRenewalIntervalInSecs();
            leaseDuration = info.getLeaseInfo().getDurationInSecs();
        }

        info.setLeaseInfo(Builder.newBuilder().setRegistrationTimestamp(lease.getRegistrationTimestamp()).setRenewalTimestamp(lease.getLastRenewalTimestamp()).setServiceUpTimestamp(lease.getServiceUpTimestamp()).setRenewalIntervalInSecs(renewalInterval).setDurationInSecs(leaseDuration).setEvictionTimestamp(lease.getEvictionTimestamp()).build());
        info.setIsCoordinatingDiscoveryServer();
        return info;
    }
```

2.修改实例状态

```java
// PeerAwareInstanceRegistryImpl.java
public boolean statusUpdate(String appName, String id, InstanceStatus newStatus, String lastDirtyTimestamp, boolean isReplication) {
    // 本地Sevre注册表修改状态
        if (super.statusUpdate(appName, id, newStatus, lastDirtyTimestamp, isReplication)) {
            // 复制同步到Server
            this.replicateToPeers(PeerAwareInstanceRegistryImpl.Action.StatusUpdate, appName, id, (InstanceInfo)null, newStatus, isReplication);
            return true;
        } else {
            return false;
        }
    }
```

修改Server注册表状态：

```java
// AbstractInstanceRegistry.java
public boolean statusUpdate(String appName, String id, InstanceStatus newStatus, String lastDirtyTimestamp, boolean isReplication) {
    this.read.lock();
     // 加了读锁，是为了实现多线程修改，而读的时候保证其他线程不修改状态。

    boolean var8;
    try {
       // 修改状态计数器+1 本地修改，底层自旋锁
        EurekaMonitors.STATUS_UPDATE.increment(isReplication);
        // 从本地缓存注册表获取 微服务 key 微服务名 value 实例集合
        Map<String, Lease<InstanceInfo>> gMap = (Map)this.registry.get(appName);
        Lease<InstanceInfo> lease = null;
        if (gMap != null) {
            // 根据实例Id 获取该续约对象
            lease = (Lease)gMap.get(id);
        }

        if (lease != null) {
            // A.续约对象续期，因为一次修改状态，也是可以认为续期
            lease.renew();
            // 获取主机实例
            InstanceInfo info = (InstanceInfo)lease.getHolder();
            if (info == null) {
                logger.error("Found Lease without a holder for instance id {}", id);
            }

            if (info != null && !info.getStatus().equals(newStatus)) {
                if (InstanceStatus.UP.equals(newStatus)) {
                    // 状态是UP，如果是第一次启动，则记录一下启动的时间戳
                    lease.serviceUp();
                }
                //  // 保存到一个维护覆盖状态的map，key是instanceId
                this.overriddenInstanceStatusMap.put(id, newStatus);
                info.setOverriddenStatus(newStatus);
                long replicaDirtyTimestamp = 0L;
                info.setStatusWithoutDirty(newStatus);
                if (lastDirtyTimestamp != null) {
                    replicaDirtyTimestamp = Long.parseLong(lastDirtyTimestamp);
                }
                 // 比较一下客户端传过来的最新修改时间是不是比我服务端记录的还新
                if (replicaDirtyTimestamp > info.getLastDirtyTimestamp()) {
                    info.setLastDirtyTimestamp(replicaDirtyTimestamp);
                }

                info.setActionType(ActionType.MODIFIED);
                // //将其加入到最近更新队列！！！这是一个线程安全的先进先出的队列
                this.recentlyChangedQueue.add(new AbstractInstanceRegistry.RecentlyChangedItem(lease));
                info.setLastUpdatedTimestamp();
                this.invalidateCache(appName, info.getVIPAddress(), info.getSecureVipAddress());
            }

            boolean var15 = true;
            return var15;
        }

        var8 = false;
    } finally {
        this.read.unlock();
    }

    return var8;
    
// Lease.java  A
public void renew() {
    this.lastUpdateTimestamp = System.currentTimeMillis() + this.duration;
}
```

Server同步到Eureka集群其他节点：

```java
@Override
    public boolean statusUpdate(final String appName, final String id,
                                final InstanceStatus newStatus, String lastDirtyTimestamp,
                                final boolean isReplication) {
        if (super.statusUpdate(appName, id, newStatus, lastDirtyTimestamp, isReplication)) {
            replicateToPeers(Action.StatusUpdate, appName, id, null, newStatus, isReplication);
            return true;
        }
        return false;
    }
    

private void replicateToPeers(Action action, String appName, String id,
                                  InstanceInfo info /* optional */,
                                  InstanceStatus newStatus /* optional */, boolean isReplication) {
        Stopwatch tracer = action.getTimer().start();
        try {
            if (isReplication) { // //是否是Server之间的复制请求，此时还是客户端发起的请求，所以是false
                numberOfReplicationsLastMin.increment();
            }
            // 如果已经是复制，则不要再次复制 peerEurekaNodes代表的就是当前Eureka Server的集群
            if (peerEurekaNodes == Collections.EMPTY_LIST || isReplication) {
                return;
            }

            for (final PeerEurekaNode node : peerEurekaNodes.getPeerEurekaNodes()) {
                // 如果URL代表此主机，请不要复制到您自己。
                if (peerEurekaNodes.isThisMyUrl(node.getServiceUrl())) {
                    continue;
                }
                // 将对eureka的操作行为复制给其他eureka节点
                replicateInstanceActionsToPeers(action, appName, id, info, newStatus, node);
            }
        } finally {
            tracer.stop();
        }
    }
```

将对eureka的操作行为复制给其他eureka节点：

```java
private void replicateInstanceActionsToPeers(Action action, String appName,
                                                 String id, InstanceInfo info, InstanceStatus newStatus,
                                                 PeerEurekaNode node) {
        try {
            InstanceInfo infoFromRegistry;
            CurrentRequestVersion.set(Version.V2);
            switch (action) {
                case Cancel:
                    node.cancel(appName, id);
                    break;
                case Heartbeat:
                    InstanceStatus overriddenStatus = overriddenInstanceStatusMap.get(id);
                    infoFromRegistry = getInstanceByAppAndId(appName, id, false);
                    node.heartbeat(appName, id, infoFromRegistry, overriddenStatus, false);
                    break;
                case Register:
                    node.register(info);
                    break;
                    // 修改状态
                case StatusUpdate:
                    infoFromRegistry = getInstanceByAppAndId(appName, id, false);
                    // 给节点同步状态更新操作
                    node.statusUpdate(appName, id, newStatus, infoFromRegistry);
                    break;
                case DeleteStatusOverride:
                    infoFromRegistry = getInstanceByAppAndId(appName, id, false);
                    node.deleteStatusOverride(appName, id, infoFromRegistry);
                    break;
            }
        } catch (Throwable t) {
            logger.error("Cannot replicate information to {} for action {}", node.getServiceUrl(), action.name(), t);
        } finally {
            CurrentRequestVersion.remove();
        }
    }
```

节点同步状态更新操作：

```java
public void statusUpdate(final String appName, final String id,
                         final InstanceStatus newStatus, final InstanceInfo info) {
    long expiryTime = System.currentTimeMillis() + maxProcessingDelayMs;
    //batchingDispatcher执行器，底层是将任务放入队列，有专门的后台线程循环从队列取任务执行
    batchingDispatcher.process(
		    //参数一：任务ID
            taskId("statusUpdate", appName, id),
            //参数二：真正要处理的任务
            new InstanceReplicationTask(targetHost, Action.StatusUpdate, info, null, false) {
                @Override
                public EurekaHttpResponse<Void> execute() {
	                //直接看statusUpdate方法
                    return replicationClient.statusUpdate(appName, id, newStatus, info);
                }
            },
            //参数三：到期时间
            expiryTime
    );
}
```

直接看statusUpdate方法：

```java
//AbstractJerseyEurekaHttpClient.java
public EurekaHttpResponse<Void> statusUpdate(String appName, String id, InstanceStatus newStatus, InstanceInfo info) {
    String urlPath = "apps/" + appName + '/' + id + "/status";
    ClientResponse response = null;
    try {
        Builder requestBuilder = jerseyClient.resource(serviceUrl)
                .path(urlPath)
                .queryParam("value", newStatus.name())
                .queryParam("lastDirtyTimestamp", info.getLastDirtyTimestamp().toString())
                .getRequestBuilder();
        //注意这里和以前的客户端发起请求不一样，当前类是JerseyReplicationClient
        //在实现的addExtraHeaders方法中，向请求头中添加了复制请求的标记
        addExtraHeaders(requestBuilder);
        //看到又是通过http方式提交put请求
        response = requestBuilder.put(ClientResponse.class);
        return anEurekaHttpResponse(response.getStatus()).headers(headersOf(response)).build();
    } finally {
        if (logger.isDebugEnabled()) {
            logger.debug("Jersey HTTP PUT {}/{}; statusCode={}", serviceUrl, urlPath, response == null ? "N/A" : response.getStatus());
        }
        if (response != null) {
            response.close();
        }
    }
}

//JerseyReplicationClient.java
protected void addExtraHeaders(Builder webResource) {
	//看到向请求头添加了HEADER_REPLICATION，代表了是Server间的复制请求
    webResource.header(PeerEurekaNode.HEADER_REPLICATION, "true");
}
```

##### 处理客户端删除状态请求

一但客户端发起了删除状态请求，服务端就不在接受来自该客户端的心跳请求

```java
//InstanceResource.java
@DELETE
@Path("status")
public Response deleteStatusUpdate(
        @HeaderParam(PeerEurekaNode.HEADER_REPLICATION) String isReplication,
        @QueryParam("value") String newStatusValue,
        @QueryParam("lastDirtyTimestamp") String lastDirtyTimestamp) {
    //入参：
    //isReplication：是否是服务端之间的复制同步请求
    //newStatusValue：我们知道客户端发起删除状态请求的时候，不会传状态，所以这里为null
    //lastDirtyTimestamp：客户端的最新修改时间戳
    try {
	    //根据微服务名称和instanceId获取注册表中的实例信息
        if (registry.getInstanceByAppAndId(app.getName(), id) == null) {
            logger.warn("Instance not found: {}/{}", app.getName(), id);
            return Response.status(Status.NOT_FOUND).build();
        }
		//为了保证服务健壮性，其实客户端发过来时newStatusValue是null
        InstanceStatus newStatus = newStatusValue == null ? InstanceStatus.UNKNOWN : InstanceStatus.valueOf(newStatusValue);
        //删除覆盖状态
        boolean isSuccess = registry.deleteStatusOverride(app.getName(), id,
                newStatus, lastDirtyTimestamp, "true".equals(isReplication));

        if (isSuccess) {
            logger.info("Status override removed: {} - {}", app.getName(), id);
            return Response.ok().build();
        } else {
            logger.warn("Unable to remove status override: {} - {}", app.getName(), id);
            return Response.serverError().build();
        }
    } catch (Throwable e) {
        logger.error("Error removing instance's {} status override", id);
        return Response.serverError().build();
    }
}
```

直接看删除覆盖状态方法：

```java
//PeerAwareInstanceRegistryImpl.java
public boolean deleteStatusOverride(String appName, String id,
                                    InstanceStatus newStatus,
                                    String lastDirtyTimestamp,
                                    boolean isReplication) {
	//调用父类先本地删除覆盖状态
    if (super.deleteStatusOverride(appName, id, newStatus, lastDirtyTimestamp, isReplication)) {
	    //删除成功后，将删除覆盖状态的操作同步给集群中的其他节点
        replicateToPeers(Action.DeleteStatusOverride, appName, id, null, null, isReplication);
        return true;
    }
    return false;
}
```

本地删除：

```java
//AbstractInstanceRegistry.java
/**
 * Removes status override for a give instance.
 * 删除给定实例的状态替代。
 * ...
 */
@Override
public boolean deleteStatusOverride(String appName, String id,
                                    InstanceStatus newStatus,
                                    String lastDirtyTimestamp,
                                    boolean isReplication) {
    try {
        read.lock();//写操作，读锁
        STATUS_OVERRIDE_DELETE.increment(isReplication);//删除状态操作计数器+1
        //获取注册表中的实例信息
        Map<String, Lease<InstanceInfo>> gMap = registry.get(appName);
        Lease<InstanceInfo> lease = null;
        if (gMap != null) {
            lease = gMap.get(id);
        }
        if (lease == null) {
            return false;
        } else {
            lease.renew();//刷新续约时间
            InstanceInfo info = lease.getHolder();//获取实例信息

            // Lease is always created with its instance info object.
            // This log statement is provided as a safeguard, in case this invariant is violated.
            if (info == null) {
                logger.error("Found Lease without a holder for instance id {}", id);
            }
			//根据instanceId删除对应的覆盖状态
            InstanceStatus currentOverride = overriddenInstanceStatusMap.remove(id);
            if (currentOverride != null && info != null) {
	            //返回值是被删除的状态，即如果删除成功的话
	            
	            //更新instanceInfo的覆盖状态为UNKNOWN
                info.setOverriddenStatus(InstanceStatus.UNKNOWN);
                //此时newStatus也是UNKNOWN
                //更新instanceInfo的状态，但不记录dirty时间戳
                info.setStatusWithoutDirty(newStatus);
                
                //比较一下客户端传过来的最新修改时间是不是比我服务端记录的还新
                //保存更新的
                long replicaDirtyTimestamp = 0;
                if (lastDirtyTimestamp != null) {
                    replicaDirtyTimestamp = Long.valueOf(lastDirtyTimestamp);
                }
                // If the replication's dirty timestamp is more than the existing one, just update
                // it to the replica's.
                if (replicaDirtyTimestamp > info.getLastDirtyTimestamp()) {
                    info.setLastDirtyTimestamp(replicaDirtyTimestamp);
                }
                //设置行为类型为修改
                info.setActionType(ActionType.MODIFIED);
                //放入最近更新队列
                recentlyChangedQueue.add(new RecentlyChangedItem(lease));
                //更新服务端的最新修改时间
                info.setLastUpdatedTimestamp();
                //让一些缓存失效
                invalidateCache(appName, info.getVIPAddress(), info.getSecureVipAddress());
            }
            return true;
        }
    } finally {
        read.unlock();
    }
}
```

删除状态操作同步给集群中其他节点：

同修改状态类似

```java
//PeerAwareInstanceRegistryImpl.java
/**
 * Replicates all eureka actions to peer eureka nodes except for replication
 * traffic to this node.
 * 将所有eureka操作复制到对等eureka节点，但复制到该节点的流量除外。
 */
private void replicateToPeers(Action action, String appName, String id,
                              InstanceInfo info /* optional */,
                              InstanceStatus newStatus /* optional */, boolean isReplication) {
    Stopwatch tracer = action.getTimer().start();
    try {
        if (isReplication) {//是否是Server之间的复制请求，此时还是客户端发起的请求，所以是false
            numberOfReplicationsLastMin.increment();
        }
        // If it is a replication already, do not replicate again as this will create a poison replication 
        // 如果已经是复制，则不要再次复制，因为这将创建有毒复制
        // peerEurekaNodes代表的就是当前Eureka Server的集群
        if (peerEurekaNodes == Collections.EMPTY_LIST || isReplication) {
            return;
        }

        for (final PeerEurekaNode node : peerEurekaNodes.getPeerEurekaNodes()) {
	        //遍历集群中所有的节点
	        
            // If the url represents this host, do not replicate to yourself.
            // 如果URL代表此主机，请不要复制到您自己。
            if (peerEurekaNodes.isThisMyUrl(node.getServiceUrl())) {
                continue;
            }
            //将对eureka的操作行为复制给其他eureka节点
            replicateInstanceActionsToPeers(action, appName, id, info, newStatus, node);
        }
    } finally {
        tracer.stop();
    }
}
```

##### 处理客户端心跳请求

```java
//InstanceResource.java
@PUT //是个PUT修改请求
public Response renewLease(
        @HeaderParam(PeerEurekaNode.HEADER_REPLICATION) String isReplication,
        @QueryParam("overriddenstatus") String overriddenStatus,
        @QueryParam("status") String status,
        @QueryParam("lastDirtyTimestamp") String lastDirtyTimestamp) {
	//入参：
	//参数一：isReplication，判断是否是Server端之间复制同步端请求
	//参数二：overriddenStatus，覆盖状态（外部应用指定的状态）
	//参数三：status，真正的状态
	//参数四：lastDirtyTimestamp，客户端的最新修改时间戳，脏时间戳
    boolean isFromReplicaNode = "true".equals(isReplication);
    //进行续约
    boolean isSuccess = registry.renew(app.getName(), id, isFromReplicaNode);

    // Not found in the registry, immediately ask for a register
    if (!isSuccess) {
	    //注册表中没有找到对应注册信息，返回404
	    //客户端发起续约请求收到404会立即进行注册
        logger.warn("Not Found (Renew): {} - {}", app.getName(), id);
        return Response.status(Status.NOT_FOUND).build();
    }
    // Check if we need to sync based on dirty time stamp, the client
    // instance might have changed some value
    // 检查我们是否需要根据脏时间戳进行同步，客户端实例可能已更改了一些值
    Response response;
    if (lastDirtyTimestamp != null && serverConfig.shouldSyncWhenTimestampDiffers()) {
        response = this.validateDirtyTimestamp(Long.valueOf(lastDirtyTimestamp), isFromReplicaNode);
        // Store the overridden status since the validation found out the node that replicates wins
        // 存储在验证发现复制的节点获胜后(谁的修改时间更新谁就获胜)的覆盖状态
        if (response.getStatus() == Response.Status.NOT_FOUND.getStatusCode()
                && (overriddenStatus != null)
                && !(InstanceStatus.UNKNOWN.name().equals(overriddenStatus))
                && isFromReplicaNode) {
            registry.storeOverriddenStatusIfRequired(app.getAppName(), id, InstanceStatus.valueOf(overriddenStatus));
        }
    } else {
	    //直接返回成功200
        response = Response.ok().build();
    }
    logger.debug("Found (Renew): {} - {}; reply status={}", app.getName(), id, response.getStatus());
    return response;
}
```

本地续约：

```java
// PeerAwareInstanceRegistryImpl.java 
public boolean renew(final String appName, final String id, final boolean isReplication) {
        if (super.renew(appName, id, isReplication)) {
            replicateToPeers(Action.Heartbeat, appName, id, null, null, isReplication);
            return true;
        }
        return false;
    }

//AbstractInstanceRegistry.java
public boolean renew(String appName, String id, boolean isReplication) {
    RENEW.increment(isReplication);//续约计数器+1
    //从注册表获取续约对象
    Map<String, Lease<InstanceInfo>> gMap = registry.get(appName);
    Lease<InstanceInfo> leaseToRenew = null;
    if (gMap != null) {
        leaseToRenew = gMap.get(id);
    }
    //续约发现注册表中对应实例注册信息为空
    if (leaseToRenew == null) {
        RENEW_NOT_FOUND.increment(isReplication);//计数器+1
        logger.warn("DS: Registry: lease doesn't exist, registering resource: {} - {}", appName, id);
        //这里返回false后，控制器那里会返回404
        //客户端收到404就会立即发起注册请求
        return false;
    } else {
	    //获取实例信息
        InstanceInfo instanceInfo = leaseToRenew.getHolder();
        if (instanceInfo != null) {
            // touchASGCache(instanceInfo.getASGName());

			// 根据覆盖状态规则 计算真正的状态
            InstanceStatus overriddenInstanceStatus = this.getOverriddenInstanceStatus(
                    instanceInfo, leaseToRenew, isReplication);
            if (overriddenInstanceStatus == InstanceStatus.UNKNOWN) {
	            //如果计算后的状态是UNKNOWN，续约就不会处理了，相当于404
	            //根据规则，可以推测状态为UNKNOWN的情况：
	            //    1.overiddenStatusMap对应的overiddenStatus状态为UNKNOWN
	            //    2.Server端注册表中该客户端的状态已经是UNKNOWN
	            //什么情况会造成上面两个情况：
	            //    客户端发起删除状态的请求的时候（此时overiddenStatusMap中对应的状态将为null，而status直接是UNKNOWN）
	            //    客户端发起修改状态的请求的时候（通过acturator直接设置overiddenStatusMap对应的overiddenStatus状态为UNKNOWN）
	            //总结：
	            //    UNKNOWN说明删除了覆盖状态需要重新注册
	            //注意：刚注册的时候overiddenStatusMap对应的overiddenStatus是
	            //  null，只有通过外部程序修改状态才会有值
                logger.info("Instance status UNKNOWN possibly due to deleted override for instance {}"
                        + "; re-register required", instanceInfo.getId());
                RENEW_NOT_FOUND.increment(isReplication);//续约对应实例为空情况的计数器+1
                //一但UNKNOWN，就不在接受心跳处理了
                //返回false，控制器会返回404，会让客户端重新发起注册！！
                return false;
            }
            if (!instanceInfo.getStatus().equals(overriddenInstanceStatus)) {
	            //实例状态与覆盖的实例状态不同，因此将实例状态设置为覆盖状态
	            //规矩覆盖状态规则推断，发生此时这种情况只可能是一种情况，
	            //就是覆盖状态的map的状态和实例本身状态不一致，所以其实是
	            //希望通过心跳，将覆盖状态和实例本身状态同步
	            //即通过覆盖状态也能修改普通状态，这应该就是意义所在
                logger.info(
                        "The instance status {} is different from overridden instance status {} for instance {}. "
                                + "Hence setting the status to overridden status", instanceInfo.getStatus().name(),
                                instanceInfo.getOverriddenStatus().name(),
                                instanceInfo.getId());
				//更新新的状态，服务端不记录dirty
                instanceInfo.setStatusWithoutDirty(overriddenInstanceStatus);

            }
        }
        renewsLastMin.increment();//计数器+1
        //真正的心跳操作，核心就这一句
        leaseToRenew.renew();
        return true;
    }
}

//Lease.java
/**
 * Renew the lease, use renewal duration if it was specified by the
 * associated {@link T} during registration, otherwise default duration is
 * {@link #DEFAULT_DURATION_IN_SECS}.
 * 续订租约，如果在注册时关联的{@link T}指定了续订期限，
 * 则使用续订期限，否则默认期限为{@link #DEFAULT_DURATION_IN_SECS}。
 */
public void renew() {
	//更新下一次续约的截止时间，一旦超过该时间没有收到续约请求，则认为挂了
    lastUpdateTimestamp = System.currentTimeMillis() + duration;

}
```

复制同步到其他节点续约：

```java
// PeerEurekaNode.java
public void heartbeat(final String appName, final String id,
                      final InstanceInfo info, final InstanceStatus overriddenStatus,
                      boolean primeConnection) throws Throwable {
    if (primeConnection) {
        // We do not care about the result for priming request.
        // 我们不在乎启动请求的结果。

		//如果是首次连接，不在乎请求的结果
		//发送心跳就不看了，就是用jersey发起put请求，相同的URI，请求头被标记为复制同步请求
        replicationClient.sendHeartBeat(appName, id, info, overriddenStatus);
        return;
    }
    //与第一次区别是需要关注请求的结果，针对结果进行不同的处理
    ReplicationTask replicationTask = new InstanceReplicationTask(targetHost, Action.Heartbeat, info, overriddenStatus, false) {
        @Override
        public EurekaHttpResponse<InstanceInfo> execute() throws Throwable {
	        //发送心跳就不看了，就是用jersey发起put请求，相同的URI，请求头被标记为复制同步请求
            return replicationClient.sendHeartBeat(appName, id, info, overriddenStatus);
        }
		//请求状态不是成功的情况处理
        @Override
        public void handleFailure(int statusCode, Object responseEntity) throws Throwable {
            super.handleFailure(statusCode, responseEntity);//简单的打印了一个日志
            if (statusCode == 404) {
                logger.warn("{}: missing entry.", getTaskName());
                if (info != null) {
                    logger.warn("{}: cannot find instance id {} and hence replicating the instance with status {}",
                            getTaskName(), info.getId(), info.getStatus());
					//响应结果是404，则发起注册请求
					//发起的是服务端之间的复制同步请求
                    register(info);
                }
            } else if (config.shouldSyncWhenTimestampDiffers()) {
	            //开启以上配置后，在Server间进行复制同步的续约请求时
	            //发现最新修改时间戳不一样会进行数据同步的操作，后面会讲到
                InstanceInfo peerInstanceInfo = (InstanceInfo) responseEntity;
                if (peerInstanceInfo != null) {
	                //peerInstanceInfo不为空，说明我发送过去的心跳，在比较dirty时间戳时
	                //发现对方的时间戳比我新，所以对方将它的实例信息发送给我让我同步更新
	                //后面马上就讲
                    syncInstancesIfTimestampDiffers(appName, id, info, peerInstanceInfo);
                }
            }
        }
    };
    long expiryTime = System.currentTimeMillis() + getLeaseRenewalOf(info);
    batchingDispatcher.process(taskId("heartbeat", info), replicationTask, expiryTime);
}
```

服务端之间的续约数据同步

回到入口InstanceResource，讲了上半部分续约处理，接下来看下半部分：

Eureka客户端每发起一种请求到Server端，在Server端处理完成后都会向其他Server发起同样的请求，以达到数据一致性，而续约心跳的Server端之间的复制同步请求，如果发现对方的脏时间戳与我本地的不一样，可以进行数据同步，需要通过如下参数开启，默认就是true：

两种情况：

对方比我新（对方发起注册）

我比对方新（对方同步我返回的信息）

![在这里插入图片描述](D:\学习\learn-docu\spirng-cloud\Eureka\0.Eureka server.assets\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTk0NzM3OA==,size_16,color_FFFFFF,t_70.png)

```java
//InstanceResource.java
@PUT //是个PUT修改请求
public Response renewLease(
        @HeaderParam(PeerEurekaNode.HEADER_REPLICATION) String isReplication,
        @QueryParam("overriddenstatus") String overriddenStatus,
        @QueryParam("status") String status,
        @QueryParam("lastDirtyTimestamp") String lastDirtyTimestamp) {
	...//省略了续约操作相关逻辑
	
    // Check if we need to sync based on dirty time stamp, the client
    // instance might have changed some value
    // 检查我们是否需要根据脏时间戳进行同步，客户端实例可能已更改了一些值
    Response response;
    if (lastDirtyTimestamp != null && serverConfig.shouldSyncWhenTimestampDiffers()) {
	    //首先验证DirtyTimestamp
        response = this.validateDirtyTimestamp(Long.valueOf(lastDirtyTimestamp), isFromReplicaNode);
        // Store the overridden status since the validation found out the node that replicates wins
        // 存储覆盖的状态，因为验证发现复制的节点的更新时间更新
        if (response.getStatus() == Response.Status.NOT_FOUND.getStatusCode()
                && (overriddenStatus != null)
                && !(InstanceStatus.UNKNOWN.name().equals(overriddenStatus))
                && isFromReplicaNode) {
			//如果response状态是404，说明请求过来的时间戳更新（看validateDirtyTimestamp方法）
			//如果是复制同步请求，并且传过来了overriddenStatus，且不为null不为UNKNOWN
			//则我会同步这个overriddenStatus,在对方收到404请求后
			//对方会向我发起注册同步请求的
            registry.storeOverriddenStatusIfRequired(app.getAppName(), id, InstanceStatus.valueOf(overriddenStatus));
        }
    } else {
	    //直接返回成功200
        response = Response.ok().build();
    }
    logger.debug("Found (Renew): {} - {}; reply status={}", app.getName(), id, response.getStatus());
    return response;
}
```

验证DirtyTimestamp：

```java
//InstanceResource.java
private Response validateDirtyTimestamp(Long lastDirtyTimestamp,
                                        boolean isReplication) {
	//获取本地注册表中的instanceInfo信息
    InstanceInfo appInfo = registry.getInstanceByAppAndId(app.getName(), id, false);
    if (appInfo != null) {
        if ((lastDirtyTimestamp != null) && (!lastDirtyTimestamp.equals(appInfo.getLastDirtyTimestamp()))) {
            Object[] args = {id, appInfo.getLastDirtyTimestamp(), lastDirtyTimestamp, isReplication};

            if (lastDirtyTimestamp > appInfo.getLastDirtyTimestamp()) {
	            //如果请求传过来的比我本地的更新
                logger.debug(
                        "Time to sync, since the last dirty timestamp differs -"
                                + " ReplicationInstance id : {},Registry : {} Incoming: {} Replication: {}",
                        args);
				//返回404，需要对方注册同步给我更新的数据
				//对方收到404会发起注册请求，通过注册方式进行数据同步，这是一种情况
                return Response.status(Status.NOT_FOUND).build();
            } else if (appInfo.getLastDirtyTimestamp() > lastDirtyTimestamp) {
	            //如果我本地比对方的新，直接将我本地的实例信息作为响应体
	            //返回给对方，让对方更新
	            
                // In the case of replication, send the current instance info in the registry for the
                // replicating node to sync itself with this one.
                // 如果是复制，请在注册表中发送当前实例信息，以使复制节点与此节点进行同步。
                if (isReplication) {
                    logger.debug(
                            "Time to sync, since the last dirty timestamp differs -"
                                    + " ReplicationInstance id : {},Registry : {} Incoming: {} Replication: {}",
                            args);
					//如果是复制同步请求，发现发过来的比我当前小，说明我更新，就返回冲突，409
					//同时响应体中包含了appInfo！当前注册表中的实例信息，让发请求过来的Server节点进行同步！
                    return Response.status(Status.CONFLICT).entity(appInfo).build();
                } else {
	                //不是Server间复制同步的请求，直接返回200，不处理
                    return Response.ok().build();
                }
            }
        }

    }
    return Response.ok().build();
```

##### 处理客户端下架请求

```java
//InstanceResource.java
@DELETE //下架是Delete请求
public Response cancelLease(
        @HeaderParam(PeerEurekaNode.HEADER_REPLICATION) String isReplication) {
    try {
	    //入参：isReplication是否是Server间复制同步请求
        boolean isSuccess = registry.cancel(app.getName(), id,
            "true".equals(isReplication));

        if (isSuccess) {
            logger.debug("Found (Cancel): {} - {}", app.getName(), id);
            //下架成功返回ok,200
            return Response.ok().build();
        } else {
            logger.info("Not Found (Cancel): {} - {}", app.getName(), id);
            //失败not found,404
            return Response.status(Status.NOT_FOUND).build();
        }
    } catch (Throwable e) {
        logger.error("Error (cancel): {} - {}", app.getName(), id, e);
        //报错,500
        return Response.serverError().build();
    }

}
```

```java
//PeerAwareInstanceRegistryImpl.java
public boolean cancel(final String appName, final String id,
                      final boolean isReplication) {
    if (super.cancel(appName, id, isReplication)) {//调用父类先本地下架
	    //下架成功后同步给其他Server
        replicateToPeers(Action.Cancel, appName, id, null, null, isReplication);
        synchronized (lock) {
	        //下架成功后 预期发送心跳续约请求的客户端数量 -1
	        //并重新计算 预期每分钟收到心跳续约请求数量
            if (this.expectedNumberOfClientsSendingRenews > 0) {
                // Since the client wants to cancel it, reduce the number of clients to send renews
                this.expectedNumberOfClientsSendingRenews = this.expectedNumberOfClientsSendingRenews - 1;
                updateRenewsPerMinThreshold();
            }
        }
        return true;
    }
    return false;
}
```

本地下架：

```java
//AbstractInstanceRegistry.java
public boolean cancel(String appName, String id, boolean isReplication) {
    return internalCancel(appName, id, isReplication);
}

//AbstractInstanceRegistry.java
protected boolean internalCancel(String appName, String id, boolean isReplication) {
    try {
        read.lock();//读锁
        CANCEL.increment(isReplication);//下架操作计数器+1
        //获取微服务对应的内层map
        Map<String, Lease<InstanceInfo>> gMap = registry.get(appName);
        //记录删除的续约对象
        Lease<InstanceInfo> leaseToCancel = null;
        if (gMap != null) {
            leaseToCancel = gMap.remove(id);//内层map删除对应实例信息
        }
        synchronized (recentCanceledQueue) {
	        //加入最近下架队列
            recentCanceledQueue.add(new Pair<Long, String>(System.currentTimeMillis(), appName + "(" + id + ")"));
        }
        //删除对应的覆盖状态
        InstanceStatus instanceStatus = overriddenInstanceStatusMap.remove(id);
        if (instanceStatus != null) {
            logger.debug("Removed instance id {} from the overridden map which has value {}", id, instanceStatus.name());
        }
        if (leaseToCancel == null) {
	        //下架的时候发现注册表中已经没有了
            CANCEL_NOT_FOUND.increment(isReplication);//计数器+1
            logger.warn("DS: Registry: cancel failed because Lease is not registered for: {}/{}", appName, id);
            //返回下架失败
            return false;
        } else {
        	//续约对象里有一个时间戳专门记录 下架时间的 evictionTimestamp
            leaseToCancel.cancel();//通过更新驱逐时间来取消租约。
            InstanceInfo instanceInfo = leaseToCancel.getHolder();
            String vip = null;
            String svip = null;
            if (instanceInfo != null) {
	            //记录行为类型
                instanceInfo.setActionType(ActionType.DELETED);
                //加入最近更新队列
                recentlyChangedQueue.add(new RecentlyChangedItem(leaseToCancel));
                //更新服务端最新修改时间
                instanceInfo.setLastUpdatedTimestamp();
                //获取此实例的虚拟Internet协议地址。 如果未指定，则默认为主机名。
                vip = instanceInfo.getVIPAddress();
                //获取此实例的安全虚拟Internet协议地址。如果未指定，则默认为主机名。
                svip = instanceInfo.getSecureVipAddress();
            }
            //使一些缓存失效
            invalidateCache(appName, vip, svip);
            logger.info("Cancelled instance {}/{} (replication={})", appName, id, isReplication);
            return true;
        }
    } finally {
        read.unlock();
    }
}
```

下架操作复制同步给其他Server：

```java
//PeerEurekaNode.java
public void cancel(final String appName, final String id) throws Exception {
    long expiryTime = System.currentTimeMillis() + maxProcessingDelayMs;
    //batchingDispatcher执行器，底层是将任务放入队列，有专门的后台线程循环从队列取任务执行
    batchingDispatcher.process(
            taskId("cancel", appName, id),
            new InstanceReplicationTask(targetHost, Action.Cancel, appName, id) {
                @Override
                public EurekaHttpResponse<Void> execute() {
                	//相同的请求，只是在请求头中添加了一个标记
                	//标记为Server端复制同步的请求
                    return replicationClient.cancel(appName, id);
                }

                @Override
                public void handleFailure(int statusCode, Object responseEntity) throws Throwable {
                    super.handleFailure(statusCode, responseEntity);
                    if (statusCode == 404) {
                        logger.warn("{}: missing entry.", getTaskName());
                    }
                }
            },
            expiryTime
    );
}
```



### 1.1.2.注入PeerEurekaNodes

服务端之前复制同步使用，代表服务端Eureka集群

```java
@Bean
@ConditionalOnMissingBean
public PeerEurekaNodes peerEurekaNodes(PeerAwareInstanceRegistry registry, ServerCodecs serverCodecs, ReplicationClientAdditionalFilters replicationClientAdditionalFilters) {
    return new EurekaServerAutoConfiguration.RefreshablePeerEurekaNodes(registry, this.eurekaServerConfig, this.eurekaClientConfig, serverCodecs, this.applicationInfoManager, replicationClientAdditionalFilters);
}
```

## 1.2.ApplicationResource

##### 处理客户端注册请求

- 启动初始化的时候直接注册（需要配置文件配置）

- 发起续约心跳请求时收到服务端404响应时，会进行注册

- 当client检测到配置更新的时候，通过注册请求向服务端同步数据

  即注册请求，除了具有注册功能外，也是客户端向服务端进行数据同步的请求

```java
//ApplicationResource.java
/**
 * Registers information about a particular instance for an
 * {@link com.netflix.discovery.shared.Application}.
 * 为{@link com.netflix.discovery.shared.Application}注册有关特定实例的信息。
 * ...
 */
@POST //看到是post请求
@Consumes({"application/json", "application/xml"})
public Response addInstance(InstanceInfo info,
                            @HeaderParam(PeerEurekaNode.HEADER_REPLICATION) String isReplication) {
	//入参：
	//info：要注册或者要更新的实例信息
	//isReplication：是否是服务端之间复制同步的请求
	
    logger.debug("Registering instance {} (replication={})", info.getId(), isReplication);
    // validate that the instanceinfo contains all the necessary required fields
    // 验证instanceinfo包含所有必需的必填字段
    // 一系列必填参数检查
    if (isBlank(info.getId())) {
        return Response.status(400).entity("Missing instanceId").build();
    } else if (isBlank(info.getHostName())) {
        return Response.status(400).entity("Missing hostname").build();
    } else if (isBlank(info.getIPAddr())) {
        return Response.status(400).entity("Missing ip address").build();
    } else if (isBlank(info.getAppName())) {
        return Response.status(400).entity("Missing appName").build();
    } else if (!appName.equals(info.getAppName())) {
        return Response.status(400).entity("Mismatched appName, expecting " + appName + " but was " + info.getAppName()).build();
    } else if (info.getDataCenterInfo() == null) {
        return Response.status(400).entity("Missing dataCenterInfo").build();
    } else if (info.getDataCenterInfo().getName() == null) {
        return Response.status(400).entity("Missing dataCenterInfo Name").build();
    }

    // handle cases where clients may be registering with bad DataCenterInfo with missing data
    // 处理客户端可能在数据缺失的情况下向错误的DataCenterInfo注册的情况
    DataCenterInfo dataCenterInfo = info.getDataCenterInfo();
    if (dataCenterInfo instanceof UniqueIdentifier) {
        String dataCenterInfoId = ((UniqueIdentifier) dataCenterInfo).getId();
        if (isBlank(dataCenterInfoId)) {
            boolean experimental = "true".equalsIgnoreCase(serverConfig.getExperimental("registration.validation.dataCenterInfoId"));
            if (experimental) {
                String entity = "DataCenterInfo of type " + dataCenterInfo.getClass() + " must contain a valid id";
                return Response.status(400).entity(entity).build();
            } else if (dataCenterInfo instanceof AmazonInfo) {
                AmazonInfo amazonInfo = (AmazonInfo) dataCenterInfo;
                String effectiveId = amazonInfo.get(AmazonInfo.MetaDataKey.instanceId);
                if (effectiveId == null) {
                    amazonInfo.getMetadata().put(AmazonInfo.MetaDataKey.instanceId.getName(), info.getId());
                }
            } else {
                logger.warn("Registering DataCenterInfo of type {} without an appropriate id", dataCenterInfo.getClass());
            }
        }
    }
	//注册
    registry.register(info, "true".equals(isReplication));
    //注册成功返回204
    return Response.status(204).build();  // 204 to be backwards compatible
}
```

```java
/**
 * Registers the information about the {@link InstanceInfo} and replicates
 * this information to all peer eureka nodes. If this is replication event
 * from other replica nodes then it is not replicated.
 * 注册有关{@link InstanceInfo}的信息，并将此信息复制到所有对等的eureka节点。 
 * 如果这是来自其他副本节点的复制事件，则不会被复制。
 * ...
 */
@Override
public void register(final InstanceInfo info, final boolean isReplication) {
	//leaseDuration：续约心跳存活时间，默认90秒
    int leaseDuration = Lease.DEFAULT_DURATION_IN_SECS;
    if (info.getLeaseInfo() != null && info.getLeaseInfo().getDurationInSecs() > 0) {
	    //如果实例信息里专门配置过，用专门配置的
        leaseDuration = info.getLeaseInfo().getDurationInSecs();
    }
    //先本地注册
    super.register(info, leaseDuration, isReplication);
    //将注册操作复制同步给其他节点
    replicateToPeers(Action.Register, info.getAppName(), info.getId(), info, null, isReplication);
}
```

###### 本地注册：

```java
//AbstractInstanceRegistry.java
/**
 * Registers a new instance with a given duration.
 * 注册具有给定持续时间的新实例。
 * ...
 */
public void register(InstanceInfo registrant, int leaseDuration, boolean isReplication) {
    try {
        read.lock();//读锁
        //从本地注册表中根据微服务名称获取内层map
        Map<String, Lease<InstanceInfo>> gMap = registry.get(registrant.getAppName());
        REGISTER.increment(isReplication);//注册操作计数器+1
        if (gMap == null) {
	        //当前要注册的应用的微服务名称对应的内层map还不存在的话，进行创建
            final ConcurrentHashMap<String, Lease<InstanceInfo>> gNewMap = new ConcurrentHashMap<String, Lease<InstanceInfo>>();
            //putIfAbsent：如果传入key对应的value已经存在，就返回存在的value，
            //不进行替换。如果不存在，就添加key和value，返回null
            gMap = registry.putIfAbsent(registrant.getAppName(), gNewMap);
            if (gMap == null) {
	            //如果之前不存在，则用这个新的，主要为了处理线程安全问题
                gMap = gNewMap;
            }
        }
        //根据instanceId获取续约对象，如果是第一次注册肯定是null
        Lease<InstanceInfo> existingLease = gMap.get(registrant.getId());
        // Retain the last dirty timestamp without overwriting it, if there is already a lease
        if (existingLease != null && (existingLease.getHolder() != null)) {
	        //更新的情况：
	        
	        //获取 服务端记录的 客户端最新修改时间戳
            Long existingLastDirtyTimestamp = existingLease.getHolder().getLastDirtyTimestamp();
            //获取 客户端传过来的最新修改时间戳
            Long registrationLastDirtyTimestamp = registrant.getLastDirtyTimestamp();
            logger.debug("Existing lease found (existing={}, provided={}", existingLastDirtyTimestamp, registrationLastDirtyTimestamp);

            // this is a > instead of a >= because if the timestamps are equal, we still take the remote transmitted
            // InstanceInfo instead of the server local copy.
            // 这是一个>而不是> =，因为如果时间戳相等，我们仍然采用远程
            // 传输的InstanceInfo而不是服务器本地副本。
            
            //比较一下客户端传过来的最新修改时间和服务端本地记录的谁更新
            //用更新的 实例信息
            if (existingLastDirtyTimestamp > registrationLastDirtyTimestamp) {
                logger.warn("There is an existing lease and the existing lease's dirty timestamp {} is greater" +
                        " than the one that is being registered {}", existingLastDirtyTimestamp, registrationLastDirtyTimestamp);
                logger.warn("Using the existing instanceInfo instead of the new instanceInfo as the registrant");
                //如果服务端本地的修改时间更新，则用本地的副本实例信息
                registrant = existingLease.getHolder();
            }
        } else {
            // The lease does not exist and hence it is a new registration
            // 新注册的情况
            synchronized (lock) {
	            //增加 预期 发送心跳续约请求的 客户端数量(配置文件中不配置该值默认为1)
	            //所以如果Server端注册了2个client，则该值为3
                if (this.expectedNumberOfClientsSendingRenews > 0) {
                    // Since the client wants to register it, increase the number of clients sending renews
                    // 由于客户端要注册，因此请增加发送心跳续约请求的客户端数量
                    this.expectedNumberOfClientsSendingRenews = this.expectedNumberOfClientsSendingRenews + 1;
                    // 更新numberOfRenewsPerMinThreshold的值
                    // 其值就是 预期每分钟收到续约请求数 的阈值
                    // 如果最后一分钟收到的续约数量低于该值就会启动自我保护机制
                    updateRenewsPerMinThreshold();
                }
            }
            logger.debug("No previous lease information found; it is new registration");
        }
        //将当前实例信息registrant 包装为一个新的 续约对象
        Lease<InstanceInfo> lease = new Lease<InstanceInfo>(registrant, leaseDuration);
        if (existingLease != null) {
	        //如果本地注册表中已经存在，记录已存在的服务启动时间
            lease.setServiceUpTimestamp(existingLease.getServiceUpTimestamp());
        }
        //注册，put操作，对应的key不存在是新增，已存在是替换，即更新
        gMap.put(registrant.getId(), lease);
        synchronized (recentRegisteredQueue) {
	        //放入最近注册的队列
            recentRegisteredQueue.add(new Pair<Long, String>(
                    System.currentTimeMillis(),
                    registrant.getAppName() + "(" + registrant.getId() + ")"));
        }
        // This is where the initial state transfer of overridden status happens
        // 这是发生覆盖状态的初始状态转移的地方
        if (!InstanceStatus.UNKNOWN.equals(registrant.getOverriddenStatus())) {
	        //如果overriddenStatus不为UNKNOWN，说明此时客户端发来的是
	        //数据同步的请求，而不是第一次注册的情况
            logger.debug("Found overridden status {} for instance {}. Checking to see if needs to be add to the "
                            + "overrides", registrant.getOverriddenStatus(), registrant.getId());
            //overriddenInstanceStatusMap：维护覆盖状态的map，key是instanceId
            //如果overriddenInstanceStatusMap中还没有对应实例的覆盖状态，
            //则将客户端传过来的覆盖状态保存到overriddenInstanceStatusMap中
            if (!overriddenInstanceStatusMap.containsKey(registrant.getId())) {
                logger.info("Not found overridden id {} and hence adding it", registrant.getId());
                //InstanceStatus中一共有5种状态，此时这里overriddenInstanceStatusMap存放
                //的状态只可能是：UP、DOWN、OUT_OF_SERVICE
                //但通过外部程序修改状态，是可以放入UNKNOWN状态的
                overriddenInstanceStatusMap.put(registrant.getId(), registrant.getOverriddenStatus());
            }
        }
        //再次从overriddenInstanceStatusMap中获取overriddenStatus
        //不为空的话说明之前曾经肯定是通过外部程序修改过状态
        //但是客户端发起同步请求的时候是不允许修改覆盖状态的
        InstanceStatus overriddenStatusFromMap = overriddenInstanceStatusMap.get(registrant.getId());
        if (overriddenStatusFromMap != null) {
            logger.info("Storing overridden status {} from map", overriddenStatusFromMap);
            //由此可见，如果服务端已经有对应实例的overriddenStatus了
            //那么注册请求是不会修改overriddenStatus状态的
            registrant.setOverriddenStatus(overriddenStatusFromMap);
        }

        // Set the status based on the overridden status rules
        // 根据覆盖状态规则设置状态
        // 这里会根据overridden status的规则，计算出InstanceInfo的真正状态status
        // 这个status真正决定了当前客户端是否能够被其他客户端进行服务发现！
        // 只有UP状态才能够被服务发现
        InstanceStatus overriddenInstanceStatus = getOverriddenInstanceStatus(registrant, existingLease, isReplication);
        // 更新status
        registrant.setStatusWithoutDirty(overriddenInstanceStatus);

        // If the lease is registered with UP status, set lease service up timestamp
        // 如果租约以UP状态注册，请设置租约服务启动的时间戳
        if (InstanceStatus.UP.equals(registrant.getStatus())) {
	        //更新serviceUpTimestamp时间戳
            lease.serviceUp();
        }
        //设置行为类型
        registrant.setActionType(ActionType.ADDED);
        //添加到最近更新队列
        recentlyChangedQueue.add(new RecentlyChangedItem(lease));
        //更新服务端的最新修改时间
        registrant.setLastUpdatedTimestamp();
        //让一些缓存失效
        invalidateCache(registrant.getAppName(), registrant.getVIPAddress(), registrant.getSecureVipAddress());
        logger.info("Registered instance {}/{} with status {} (replication={})",
                registrant.getAppName(), registrant.getId(), registrant.getStatus(), isReplication);
    } finally {
        read.unlock();
    }
}
```

1.更新预期每分钟收到续约请求数的阈值

关于新注册的情况，增加expectedNumberOfClientsSendingRenews值，并计算numberOfRenewsPerMinThreshold，numberOfRenewsPerMinThreshold 就是我们以前打开Eureka监控页面看到的Renews threshold，预期每分钟收到续约数的阈值：
![image-20220119105901037](D:\学习\learn-docu\spirng-cloud\Eureka\0.Eureka server.assets\image-20220119105901037-16425611575221.png)

```java
//AbstractInstanceRegistry.java
protected void updateRenewsPerMinThreshold() {
	//serverConfig.getExpectedClientRenewalIntervalSeconds()：预期客户端发送心跳的时间间隔。 默认为30秒。
	//serverConfig.getRenewalPercentThreshold():在{@link #getRenewalThresholdUpdateIntervalMs（）}指定
	//  的时间段内，客户端期望的最小续订百分比。如果续订下降到阈值以下，就会启动自我保护机制。默认0.85
    this.numberOfRenewsPerMinThreshold = (int) (this.expectedNumberOfClientsSendingRenews
            * (60.0 / serverConfig.getExpectedClientRenewalIntervalSeconds())
            * serverConfig.getRenewalPercentThreshold());
}
```

![image-20220119110005842](D:\学习\learn-docu\spirng-cloud\Eureka\0.Eureka server.assets\image-20220119110005842-16425612082032.png)

1.2 根据覆盖状态规则设置状态

**关于InstanceInfo中的两个状态，overriddenStatus和status：**

**先抛开overriddenStatus，只看status。**
**InstanceInfo代表一个主机实例信息，如果客户端向服务端注册了，那么服务端和客户端都会维护一个InstanceInfo信息。客户端的InstanceInfo代表了自己，服务端的InstanceInfo是在注册表中该客户端的注册信息。**

**客户端的InstanceInfo的status代表的是这个客户端真正的工作状态，而服务端的InstanceInfo的status，是在进行服务发现时希望暴露给其他客户端的工作状态。所以同一个客户端的InstanceInfo，在客户端本地的status和在服务端注册表中的status并不一定是完全一样的。**

**那么客户端如何去修改服务端注册表中它的实例信息的status？**
**就是通过overriddenStatus，客户端发起修改状态请求传递给服务的状态就是通过overriddenStatus字段，服务端收到overriddenStatus会将它保存起来，并会根据一套覆盖状态的规则，计算出真正的InstanceInfo在服务端注册表中的status，而服务端注册表中的status并不会影响到客户端自己的status，并且客户端之后发起的所有向服务端同步数据的请求，服务端在进行状态处理时，并不会直接拿客户端传过来的status更新，而是根据覆盖状态的规则计算出status。**

根据overridden status的规则，计算出InstanceInfo的真正状态status
这个status真正决定了当前客户端是否能够被其他客户端进行服务发现！只有UP状态才能被服务发现。

![image-20220119111353636](D:\学习\learn-docu\spirng-cloud\Eureka\0.Eureka server.assets\image-20220119111353636-16425620357953.png)

```java
// AbstractInstanceRegistry,java
protected InstanceInfo.InstanceStatus getOverriddenInstanceStatus(InstanceInfo r,
                                                                    Lease<InstanceInfo> existingLease,
                                                                    boolean isReplication) {
        // 构建规则
        InstanceStatusOverrideRule rule = getInstanceInfoOverrideRule();
        logger.debug("Processing override status using rule: {}", rule);
       // 规则计算出最终状态
        return rule.apply(r, existingLease, isReplication).status();
    }
```

查看构造规则：

```java
 // PeerAwareInstanceRegistryImpl的构造
    @Override
    protected InstanceStatusOverrideRule getInstanceInfoOverrideRule() {
        return this.instanceStatusOverrideRule;
    }

    @Inject
    public PeerAwareInstanceRegistryImpl(
            EurekaServerConfig serverConfig,
            EurekaClientConfig clientConfig,
            ServerCodecs serverCodecs,
            EurekaClient eurekaClient
    ) {
        super(serverConfig, clientConfig, serverCodecs);
        this.eurekaClient = eurekaClient;
        this.numberOfReplicationsLastMin = new MeasuredRate(1000 * 60 * 1);
        // 我们首先检查实例是STARTING还是DOWN，然后检查显式替代，然后检查可能存在的租约状态。
        // 里面放了3个规则，有序的：DownOrStartingRule、OverrideExistsRule、LeaseExistsRule，
        this.instanceStatusOverrideRule = new FirstMatchWinsCompositeRule(new DownOrStartingRule(),
                new OverrideExistsRule(overriddenInstanceStatusMap), new LeaseExistsRule());
    }
```

根据规则计算出最终状态：

```java
// FirstMatchWinsCompositeRule.java
    @Override
    public StatusOverrideResult apply(InstanceInfo instanceInfo,
                                      Lease<InstanceInfo> existingLease,
                                      boolean isReplication) {
        for (int i = 0; i < this.rules.length; ++i) {
            StatusOverrideResult result = this.rules[i].apply(instanceInfo, existingLease, isReplication);
            if (result.matches()) {
                return result;
            }
        }
        return defaultRule.apply(instanceInfo, existingLease, isReplication);
    }

    @Override
    public String toString() {
        return this.compositeRuleName;
    }
```

- 按序先看DownOrStartingRule

  ```java
  //DownOrStartingRule.java
  public StatusOverrideResult apply(InstanceInfo instanceInfo,
                                    Lease<InstanceInfo> existingLease,
                                    boolean isReplication) {
      // ReplicationInstance is DOWN or STARTING - believe that, but when the instance says UP, question that
      // The client instance sends STARTING or DOWN (because of heartbeat failures), then we accept what
      // the client says. The same is the case with replica as well.
      // The OUT_OF_SERVICE from the client or replica needs to be confirmed as well since the service may be
      // currently in SERVICE
      
      // ReplicationInstance是DOWN或STARTING-是可信的，但是当实例说UP时，就需要质疑了
      // 客户端实例发送STARTING或DOWN（由于心跳失败），那么我们接受客户端所说的。 相同的场景复制也是如此。 
      // 客户端、复制传来的是OUT_OF_SERVICE则需要确认，因为该服务当前可能正在服务当中
      if ((!InstanceInfo.InstanceStatus.UP.equals(instanceInfo.getStatus()))
              && (!InstanceInfo.InstanceStatus.OUT_OF_SERVICE.equals(instanceInfo.getStatus()))) {
  		//当前状态不是UP也不是OUT_OF_SERVICE
          logger.debug("Trusting the instance status {} from replica or instance for instance {}",
                  instanceInfo.getStatus(), instanceInfo.getId());
  		
  		//那就是DOWN或STARTING，返回匹配成功
          return StatusOverrideResult.matchingStatus(instanceInfo.getStatus());
      }
      //返回没有匹配上
      return StatusOverrideResult.NO_MATCH;
  }
  
  //StatusOverrideResult.java
  public static StatusOverrideResult matchingStatus(InstanceInfo.InstanceStatus status) {
      return new StatusOverrideResult(true, status);
  }
  ```

- OverrideExistsRule

  ```java
  //OverrideExistsRule.java
  //此规则检查是否有实例的替代，如果有，则返回它们。
  public StatusOverrideResult apply(InstanceInfo instanceInfo, Lease<InstanceInfo> existingLease, boolean isReplication) {
  	//根据上一个规则，走到这，状态肯定是UP或者OUT_OF_SERVICE
  	
      InstanceInfo.InstanceStatus overridden = statusOverrides.get(instanceInfo.getId());
      // If there are instance specific overrides, then they win - otherwise the ASG status
      // 如果存在实例特定的替代，则它们获胜-否则为ASG状态
      // (ASG是亚马逊云的一个规则，见AwsInstanceRegistry这个类,我们这里下一个是LeaseExistsRule)
      if (overridden != null) {
          logger.debug("The instance specific override for instance {} and the value is {}",
                  instanceInfo.getId(), overridden.name());
  		//覆盖状态不为空直接返回匹配成功
          return StatusOverrideResult.matchingStatus(overridden);
      }
      //返回匹配失败
      return StatusOverrideResult.NO_MATCH;
  }
  ```

- LeaseExistsRule

  如果上一步也没有匹配成功，到这只能说明是UP状态，并且是没有通过外部程序修改过状态的

  ```java
  //LeaseExistsRule.java
  public StatusOverrideResult apply(InstanceInfo instanceInfo,
                                    Lease<InstanceInfo> existingLease,
                                    boolean isReplication) {
      // This is for backward compatibility until all applications have ASG
      // names, otherwise while starting up
      // the client status may override status replicated from other servers
      if (!isReplication) {//判断是否是Server之间进行复制同步，不是才会处理
          InstanceInfo.InstanceStatus existingStatus = null;
          if (existingLease != null) {
  	        //获取Server端本地的instanceInfo状态
  	        //existingStatus不空说明当前实例之前就注册过了
  	        //这次是客户端发起的数据同步的请求
              existingStatus = existingLease.getHolder().getStatus();
          }
          // Allow server to have its way when the status is UP or OUT_OF_SERVICE
          if ((existingStatus != null)
                  && (InstanceInfo.InstanceStatus.OUT_OF_SERVICE.equals(existingStatus)
                  || InstanceInfo.InstanceStatus.UP.equals(existingStatus))) {
  			//之前已经注册过了，并且状态已经是UP或OUT_OF_SERVICE
  			//则返回之前一直维持的状态
              logger.debug("There is already an existing lease with status {}  for instance {}",
                      existingLease.getHolder().getStatus().name(),
                      existingLease.getHolder().getId());
              return StatusOverrideResult.matchingStatus(existingLease.getHolder().getStatus());
          }
      }
      //如果是Server端之间的复制同步请求，则直接返回匹配失败
      return StatusOverrideResult.NO_MATCH;
  }
  ```

- AlwaysMatchInstanceStatusRule

  如果是第一次注册，也不是Server端之间的复制同步请求，则走最后一个规则

  ```java
  //AlwaysMatchInstanceStatusRule.java
  public StatusOverrideResult apply(InstanceInfo instanceInfo,
                                    Lease<InstanceInfo> existingLease,
                                    boolean isReplication) {
      logger.debug("Returning the default instance status {} for instance {}", instanceInfo.getStatus(),
              instanceInfo.getId());
  	//直接返回当前实例的状态
      return StatusOverrideResult.matchingStatus(instanceInfo.getStatus());
  }
  ```

**状态总结**：

- DownOrStartingRule：

  你告诉我你是DOWN或STARTING，DOWN或STARTING状态是可信的直接匹配成功，UP和OUT_OF_SERVICE需要进一步确认

- OverrideExistsRule：

  从overridenStatusMap获取状态，有就直接返回，匹配成功，overridenStatus是外部程序（actuator）指定的状态，OUT_OF_SERVICE这个状态只能是通过外部程序修改

- LeaseExistsRule：

  如果发现已经注册过了，即此时该请求是是客户端发起的数据同步的请求，并且之前的状态就是UP和OUT_OF_SERVICE则匹配成功

- AlwaysMatchInstanceStatusRule：

  以上规则都没满足最终直接返回当前实例状态

###### 注册操作复制同步给其他节点：

注册成功后，将注册操作复制同步给集群中其他Server(这个跟修改状态基本完全一样)

## 1.3.ApplicationsResource

#### 处理客户端全量下载请求

[处理客户端全量下载请求](https://blog.csdn.net/weixin_41947378/article/details/109147558?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164198228816780255299187%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=164198228816780255299187&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-4-109147558.nonecase&utm_term=Spring+Cloud+Eureka+Server&spm=1018.2226.3001.4450)



#### 处理客户端增量下载请求

[处理客户端增量下载请求](https://blog.csdn.net/weixin_41947378/article/details/109161546?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164198228816780255299187%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=164198228816780255299187&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-7-109161546.nonecase&utm_term=Spring+Cloud+Eureka+Server&spm=1018.2226.3001.4450)



## 1.4.EurekaServerInitializerConfiguration

通过EurekaServerAutoConfiguration引入

![image-20220120111333153](D:\学习\learn-docu\spirng-cloud\Eureka\0.Eureka server.assets\image-20220120111333153-16426484191811.png)

##### 作用：定时清理过期的Client

1、入口方法：

```java
//EurekaServerInitializerConfiguration.java
public void start() {
	new Thread(() -> {
		try {
			// TODO: is this class even needed now?
			//其他内容就不看了，直接找到我们需要关注的两个任务
			//看contextInitialized方法
			eurekaServerBootstrap.contextInitialized(
					EurekaServerInitializerConfiguration.this.servletContext);
			log.info("Started Eureka Server");

			publish(new EurekaRegistryAvailableEvent(getEurekaServerConfig()));
			EurekaServerInitializerConfiguration.this.running = true;
			publish(new EurekaServerStartedEvent(getEurekaServerConfig()));
		}
		catch (Exception ex) {
			// Help!
			log.error("Could not initialize Eureka servlet context", ex);
		}
	}).start();
}

//EurekaServerBootstrap.java
public void contextInitialized(ServletContext context) {
	try {
		initEurekaEnvironment();
		//看这，初始化EurekaServer上下文
		initEurekaServerContext();

		context.setAttribute(EurekaServerContext.class.getName(), this.serverContext);
	}
	catch (Throwable e) {
		log.error("Cannot bootstrap eureka server :", e);
		throw new RuntimeException("Cannot bootstrap eureka server :", e);
	}
}

//EurekaServerBootstrap.java
protected void initEurekaServerContext() throws Exception {
	// For backward compatibility
	JsonXStream.getInstance().registerConverter(new V1AwareInstanceInfoConverter(),
			XStream.PRIORITY_VERY_HIGH);
	XmlXStream.getInstance().registerConverter(new V1AwareInstanceInfoConverter(),
			XStream.PRIORITY_VERY_HIGH);

	if (isAws(this.applicationInfoManager.getInfo())) {
		this.awsBinder = new AwsBinderDelegate(this.eurekaServerConfig,
				this.eurekaClientConfig, this.registry, this.applicationInfoManager);
		this.awsBinder.start();
	}

	EurekaServerContextHolder.initialize(this.serverContext);

	log.info("Initialized server context");

	// Copy registry from neighboring eureka node
	// 从邻近的eureka节点复制注册表
	// 从对等eureka节点填充注册表信息。如果通信失败，此操作将失
	// 败转移到其他节点，直到列表耗尽为止。
	// registryCount：表示从其他eureka节点下载到的注册信息中所有实例数量
	int registryCount = this.registry.syncUp();
	// 走这，打开交通
	this.registry.openForTraffic(this.applicationInfoManager, registryCount);

	// Register all monitoring statistics.
	EurekaMonitors.registerAllStats();
}

//InstanceRegistry.java
/**
 * If
 * {@link PeerAwareInstanceRegistryImpl#openForTraffic(ApplicationInfoManager, int)}
 * is called with a zero argument, it means that leases are not automatically
 * cancelled if the instance hasn't sent any renewals recently. This happens for a
 * standalone server. It seems like a bad default, so we set it to the smallest
 * non-zero value we can, so that any instances that subsequently register can bump up
 * the threshold.
 * 如果用一个零参数调用{@link PeerAwareInstanceRegistryImpl#openForTraffic(ApplicationInfoManager, int)}，
 * 这意味着如果实例最近没有发送任何续订，租约不会自动取消。这种情况发生在独立服务器上。
 * 这似乎是一个糟糕的默认值，因此我们将其设置为尽可能小的非零值，以便随后注册的任何实例都可以提高阈值。
 */
public void openForTraffic(ApplicationInfoManager applicationInfoManager, int count) {
	//count值，是服务端一开始启动的时候 从其他eureka节点下载到的注册信息中所有实例数量
	//defaultOpenForTrafficCount默认为1
	super.openForTraffic(applicationInfoManager,
			count == 0 ? this.defaultOpenForTrafficCount : count);
}

//PeerAwareInstanceRegistryImpl.java
public void openForTraffic(ApplicationInfoManager applicationInfoManager, int count) {
    // Renewals happen every 30 seconds and for a minute it should be a factor of 2.
    // 如果每30秒发生一次续约操作，一分钟内应该是2次数
    this.expectedNumberOfClientsSendingRenews = count;
    // 更新预期每分钟收到续约请求数的阈值
    updateRenewsPerMinThreshold();
    logger.info("Got {} instances from neighboring DS node", count);
    logger.info("Renew threshold is: {}", numberOfRenewsPerMinThreshold);
    this.startupTime = System.currentTimeMillis();
    if (count > 0) {
    	//count值，是服务端一开始启动的时候 从其他eureka节点下载到的注册信息中所有实例数量
    	//如果服务器无法在启动时从对等eureka节点获取注册表信息
    	//那么在指定的期限内，服务器不会返回注册表信息（全量下载中提到过）
        this.peerInstancesTransferEmptyOnStartup = false;
    }
    DataCenterInfo.Name selfName = applicationInfoManager.getInfo().getDataCenterInfo().getName();
    boolean isAws = Name.Amazon == selfName;
    if (isAws && serverConfig.shouldPrimeAwsReplicaConnections()) {
        logger.info("Priming AWS connections for all replicas..");
        primeAwsReplicas(applicationInfoManager);
    }
    logger.info("Changing status to UP");
    //设置此实例的状态。应用程序可以使用它来指示是否已准备好接收流量。
    //在这里设置状态还会通知所有已注册的侦听器状态更改事件。
    applicationInfoManager.setInstanceStatus(InstanceStatus.UP);
    //看super
    super.postInit();
}

//AbstractInstanceRegistry.java
protected void postInit() {
	//统计最后一分钟收到的续约心跳数的定时任务
    renewsLastMin.start();
    //evictionTaskRef是个原子引用，放的就是定时清除过期clien的任务，驱逐任务
    if (evictionTaskRef.get() != null) {
	    //取消之前已经存在的驱逐任务
        evictionTaskRef.get().cancel();
    }
    //新建一个驱逐任务
    evictionTaskRef.set(new EvictionTask());
    //启动驱逐任务,repeated任务，固定时间循环定时执行
    //serverConfig.getEvictionIntervalTimerInMs()：驱逐任务循环执行的间隔时间
    evictionTimer.schedule(evictionTaskRef.get(),
            serverConfig.getEvictionIntervalTimerInMs(),
            serverConfig.getEvictionIntervalTimerInMs());
}
```

2、统计最后一分钟收到的续约心跳数的定时任务

![image-20220120112129861](D:\学习\learn-docu\spirng-cloud\Eureka\0.Eureka server.assets\image-20220120112129861-16426488936622.png)

```java
//MeasuredRate.java
public synchronized void start() {
    if (!isActive) {
        timer.schedule(new TimerTask() {

            @Override
            public void run() {
                try {
                    // Zero out the current bucket.
                    // lastBucket就是当前最后一分钟收到的续约心跳数
                    // currentBucket是正在统计中收到的续约心跳数
                    // 可以看到每60秒就会从currentBucket获取统计的数量，赋值给lastBucket
                    // 同时会清空currentBucket已经统计的数量
                    lastBucket.set(currentBucket.getAndSet(0));
                } catch (Throwable e) {
                    logger.error("Cannot reset the Measured Rate", e);
                }
            } //sampleInterval就是传入的60秒，每60秒统计一次
        }, sampleInterval, sampleInterval);

        isActive = true;
    }
}
```

![img](https://img-blog.csdnimg.cn/20201020125430251.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTk0NzM3OA==,size_16,color_FFFFFF,t_70)

注意，图中两个调用点，分别是两个任务实例，分开统计的。

3、定时清理过期Client

```java
//AbstractInstanceRegistry.java
protected void postInit() {
	//当前最后一分钟收到的续约心跳数 统计的定时任务
    renewsLastMin.start();
    //evictionTaskRef是个原子引用，放的就是定时清除过期clien的任务，驱逐任务
    if (evictionTaskRef.get() != null) {
	    //取消之前已经存在的驱逐任务
        evictionTaskRef.get().cancel();
    }
    //新建一个驱逐任务
    evictionTaskRef.set(new EvictionTask());
    //启动驱逐任务,repeated任务，固定时间循环定时执行
    //serverConfig.getEvictionIntervalTimerInMs()：驱逐任务循环执行的间隔时间
    evictionTimer.schedule(evictionTaskRef.get(),
            serverConfig.getEvictionIntervalTimerInMs(),
            serverConfig.getEvictionIntervalTimerInMs());
}
```

![img](D:\学习\learn-docu\spirng-cloud\Eureka\0.Eureka server.assets\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTk0NzM3OA==,size_16,color_FFFFFF,t_70.png)

```java
//AbstractInstanceRegistry.EvictionTask.java（内部类）
class EvictionTask extends TimerTask {
	//记录上一次执行清除的时间点
    private final AtomicLong lastExecutionNanosRef = new AtomicLong(0l);

    @Override
    public void run() {
        try {
	         //计算补偿时间
            long compensationTimeMs = getCompensationTimeMs();
            logger.info("Running the evict task with compensationTime {}ms", compensationTimeMs);
            //执行清除
            evict(compensationTimeMs);
        } catch (Throwable e) {
            logger.error("Could not run the evict task", e);
        }
    }
    ...
}
```

先看计算补偿时间：

```java
//AbstractInstanceRegistry.EvictionTask#getCompensationTimeMs
/**
 * compute a compensation time defined as the actual time this task was executed since the prev iteration,
 * vs the configured amount of time for execution. This is useful for cases where changes in time (due to
 * clock skew or gc for example) causes the actual eviction task to execute later than the desired time
 * according to the configured cycle.
 * 
 * 计算补偿时间，该补偿时间定义为自上次迭代以来此任务实际执行的时间，与配置的执行时间之比。 
 * 当时间变化（例如由于时钟偏斜或gc）导致实际驱逐任务的执行时间晚于所需时间（根据配置的周期）
 * 时，此功能很有用。
 */
long getCompensationTimeMs() {
	//获取当前时间
    long currNanos = getCurrentTimeNano();
    //获取上一次清除开始的时间，并赋值这一次的开始时间
    //第一次执行获取是0
    long lastNanos = lastExecutionNanosRef.getAndSet(currNanos);
    if (lastNanos == 0l) {
        return 0l;
    }
	//本次开始执行的时间 距离 上一次开始执行的时间，大部分情况下应该就是定时任务执行的时间间隔
	//但是实际执行的时间是有可能超过配置的定时时间间隔，这个时候就可以理解为清除任务执行完的耗时时间
	//这个时间最低不会低于定时任务的定时间隔时间
    long elapsedMs = TimeUnit.NANOSECONDS.toMillis(currNanos - lastNanos);
    //减去配置的定时时间间隔，如果大于0，说明上一次执行任务的耗时超过了定时时间间隔
    //导致此次执行任务的时间晚于应该执行的时间，所以要加上这个补偿时间
    //在这个补偿时间之内的client也是过期的，也需要清楚
    long compensationTime = elapsedMs - serverConfig.getEvictionIntervalTimerInMs();
    return compensationTime <= 0l ? 0l : compensationTime;
}
```

清理：

```java
//AbstractInstanceRegistry.java
public void evict(long additionalLeaseMs) {
    logger.debug("Running the evict task");
	//是否允许续约过期，允许为true，不允许为false
	//底层其实就是判断自我保护机制启动没有，false不允许续约过期，其实就是自我保护机制启动了
	//自我保护机制开启的规则是：最后一分钟收到的续约心跳数 低于  预期每分钟收到的续约心跳数
	//这些前面几章都说过就不看了
    if (!isLeaseExpirationEnabled()) {
        logger.debug("DS: lease expiration is currently disabled.");
        return;
    }

    // We collect first all expired items, to evict them in random order. For large eviction sets,
    // if we do not that, we might wipe out whole apps before self preservation kicks in. By randomizing it,
    // the impact should be evenly distributed across all applications.
    // 我们首先收集所有过期的元素，以随机顺序将其逐出。 对于大型驱逐集，如果不这样做，
    // 我们可能会在自我保护开始之前就清除整个应用程序。通过将其随机化，影响应平均分布
    // 在所有应用程序中。
    List<Lease<InstanceInfo>> expiredLeases = new ArrayList<>();
    //registry，本地注册表
    for (Entry<String, Map<String, Lease<InstanceInfo>>> groupEntry : registry.entrySet()) {
	    //遍历获取内层map
        Map<String, Lease<InstanceInfo>> leaseMap = groupEntry.getValue();
        if (leaseMap != null) {
            for (Entry<String, Lease<InstanceInfo>> leaseEntry : leaseMap.entrySet()) {
                Lease<InstanceInfo> lease = leaseEntry.getValue();
	            //判断是否过期，过期加入expiredLeases集合
	            //看到过期方法，传入了补偿时间
                if (lease.isExpired(additionalLeaseMs) && lease.getHolder() != null) {
                    expiredLeases.add(lease);
                }
            }
        }
    }

    // To compensate for GC pauses or drifting local time, we need to use current registry size as a base for
    // triggering self-preservation. Without that we would wipe out full registry.
    // 为了补偿GC暂停或本地时间漂移，我们需要使用当前注册表大小作为触发自我保护的基础。 
    // 否则，我们将清除完整的注册表。
    int registrySize = (int) getLocalRegistrySize();//当前注册表中所有实例数量
    int registrySizeThreshold = (int) (registrySize * serverConfig.getRenewalPercentThreshold());//保护机制开启的阈值
    //计算允许清除的最多数量
    int evictionLimit = registrySize - registrySizeThreshold;
	//已经过期的数量  和 允许清除的最多数量 之间  取最小值
    int toEvict = Math.min(expiredLeases.size(), evictionLimit);
    if (toEvict > 0) {
        logger.info("Evicting {} items (expired={}, evictionLimit={})", toEvict, expiredLeases.size(), evictionLimit);

        Random random = new Random(System.currentTimeMillis());
        for (int i = 0; i < toEvict; i++) {
            // Pick a random item (Knuth shuffle algorithm)
            int next = i + random.nextInt(expiredLeases.size() - i);
            //在指定列表中的指定位置交换元素。为了随机删除
            Collections.swap(expiredLeases, i, next);
            //获取交换后的进行删除
            Lease<InstanceInfo> lease = expiredLeases.get(i);

            String appName = lease.getHolder().getAppName();
            String id = lease.getHolder().getId();
            EXPIRED.increment();
            logger.warn("DS: Registry: expired lease for {}/{}", appName, id);
            //内部清除
            internalCancel(appName, id, false);
        }
    }
}
```

判断是否过期：

```java
//Lease.java
public boolean isExpired(long additionalLeaseMs) {
	//evictionTimestamp：驱逐时间，下架的时候会赋值，不为空说明已经下架了
	//lastUpdateTimestamp：最近一次心跳续约时间
	//duration：续约的过期时间（默认90秒，超过该时间认为挂了）
	//additionalLeaseMs：补偿时间，补偿上一次清除任务执行的耗时超过了定时执行的间隔时间的时间
	
	//有驱逐时间说明被下架了，认为过期
	//超过指定时间没有收到心跳，认为过期
    return (evictionTimestamp > 0 || System.currentTimeMillis() > (lastUpdateTimestamp + duration + additionalLeaseMs));
}
```

内部清理(跟下架方法一样)：

```java
//AbstractInstanceRegistry.java
protected boolean internalCancel(String appName, String id, boolean isReplication) {
    try {
        read.lock();//读锁
        CANCEL.increment(isReplication);//下架操作计数器+1
        Map<String, Lease<InstanceInfo>> gMap = registry.get(appName);
        //记录删除的续约对象
        Lease<InstanceInfo> leaseToCancel = null;
        if (gMap != null) {
	        //核心方法就是这个remove
            leaseToCancel = gMap.remove(id);
        }
        synchronized (recentCanceledQueue) {
            recentCanceledQueue.add(new Pair<Long, String>(System.currentTimeMillis(), appName + "(" + id + ")"));
        }
        //overriddenStatus的清除
        InstanceStatus instanceStatus = overriddenInstanceStatusMap.remove(id);
        if (instanceStatus != null) {
            logger.debug("Removed instance id {} from the overridden map which has value {}", id, instanceStatus.name());
        }
        if (leaseToCancel == null) {
        	//下架的时候发现注册表中已经没有了
            CANCEL_NOT_FOUND.increment(isReplication);
            logger.warn("DS: Registry: cancel failed because Lease is not registered for: {}/{}", appName, id);
            return false;
        } else {
        	//续约对象里有一个时间戳专门记录 下架时间的 evictionTimestamp
        	//通过更新驱逐时间来取消租约。
            leaseToCancel.cancel();
            InstanceInfo instanceInfo = leaseToCancel.getHolder();
            String vip = null;
            String svip = null;
            if (instanceInfo != null) {
            	//记录行为类型
                instanceInfo.setActionType(ActionType.DELETED);
                //加入最近更新队列
                recentlyChangedQueue.add(new RecentlyChangedItem(leaseToCancel));
                //更新服务端最新修改时间
                instanceInfo.setLastUpdatedTimestamp();
                //获取此实例的虚拟Internet协议地址。 如果未指定，则默认为主机名。
                vip = instanceInfo.getVIPAddress();
                //获取此实例的安全虚拟Internet协议地址。如果未指定，则默认为主机名。
                svip = instanceInfo.getSecureVipAddress();
            }
            //是对应微服务相关缓存失效
            invalidateCache(appName, vip, svip);
            logger.info("Cancelled instance {}/{} (replication={})", appName, id, isReplication);
            return true;
        }
    } finally {
        read.unlock();
    }
}
```



# 问题：

### 为什么有些方法加锁、有些方法不加锁？

本质原因：读锁之间不互斥，读写锁、写锁之间互斥。

- 回顾过程中其实已经发现，这里的读写锁其实是专门为 最近更新队列服务的，一但操作流程中要对该队列进行操作，就会加锁。
- 如果一个线程持有读锁，其他线程再去获取读锁都是可以的立即获取到的，但是如果获取写锁就会阻塞等待锁释放了，相反，如果一个线程持有写锁，其他线程无论想获取读锁还是写锁都会阻塞。
- 本身最近更新队列就是一个线程安全的队列，所以多个线程同时处理是不会有线程安全问题的，写操作加读锁的意义其实是为了读操作，当增量下载进行读数据的时候，获取的是写锁，这样其他线程想要修改数据首先要获取读锁，此时就会阻塞，保证了读的时候都不能进行写操作，保证了读数据时的稳定。